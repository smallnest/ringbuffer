
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ringbuffer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/smallnest/ringbuffer/pipe.go (100.0%)</option>
				
				<option value="file1">github.com/smallnest/ringbuffer/ring_buffer.go (92.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2019 smallnest. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package ringbuffer

import "io"

// Pipe creates an asynchronous in-memory pipe compatible with io.Pipe
// It can be used to connect code expecting an [io.Reader]
// with code expecting an [io.Writer].
//
// Reads and Writes will go to the ring buffer.
// Writes will complete as long as the data fits within the ring buffer.
// Reads will attempt to satisfy reads with data from the ring buffer.
// Only if the ring buffer is empty will the read block.
//
// It is safe (and intended) to call Read and Write in parallel with each other or with Close.
func (r *RingBuffer) Pipe() (*PipeReader, *PipeWriter) <span class="cov6" title="24">{
        r.SetBlocking(true)
        pr := PipeReader{pipe: r}
        return &amp;pr, &amp;PipeWriter{pipe: r}
}</span>

// A PipeReader is the read half of a pipe.
type PipeReader struct{ pipe *RingBuffer }

// Read implements the standard Read interface:
// it reads data from the pipe, blocking until a writer
// arrives or the write end is closed.
// If the write end is closed with an error, that error is
// returned as err; otherwise err is io.EOF.
func (r *PipeReader) Read(data []byte) (n int, err error) <span class="cov10" title="156">{
        return r.pipe.Read(data)
}</span>

// Close closes the reader; subsequent writes to the
// write half of the pipe will return the error [io.ErrClosedPipe].
func (r *PipeReader) Close() error <span class="cov5" title="14">{
        r.pipe.setErr(io.ErrClosedPipe, false)
        return nil
}</span>

// CloseWithError closes the reader; subsequent writes
// to the write half of the pipe will return the error err.
//
// CloseWithError never overwrites the previous error if it exists
// and always returns nil.
func (r *PipeReader) CloseWithError(err error) error <span class="cov4" title="6">{
        if err == nil </span><span class="cov2" title="2">{
                return r.Close()
        }</span>
        <span class="cov3" title="4">r.pipe.setErr(err, false)
        return nil</span>
}

// A PipeWriter is the write half of a pipe.
type PipeWriter struct{ pipe *RingBuffer }

// Write implements the standard Write interface:
// it writes data to the pipe.
// The Write will block until all data has been written to the ring buffer.
// If the read end is closed with an error, that err is
// returned as err; otherwise err is [io.ErrClosedPipe].
func (w *PipeWriter) Write(data []byte) (n int, err error) <span class="cov7" title="35">{
        if n, err = w.pipe.Write(data); err == ErrWriteOnClosed </span><span class="cov1" title="1">{
                // Replace error.
                err = io.ErrClosedPipe
        }</span>
        <span class="cov7" title="35">return n, err</span>
}

// Close closes the writer; subsequent reads from the
// read half of the pipe will return no bytes and EOF.
func (w *PipeWriter) Close() error <span class="cov6" title="17">{
        w.pipe.setErr(io.EOF, false)
        return nil
}</span>

// CloseWithError closes the writer; subsequent reads from the
// read half of the pipe will return no bytes and the error err,
// or EOF if err is nil.
//
// CloseWithError never overwrites the previous error if it exists
// and always returns nil.
func (w *PipeWriter) CloseWithError(err error) error <span class="cov4" title="6">{
        if err == nil </span><span class="cov2" title="2">{
                return w.Close()
        }</span>
        <span class="cov3" title="4">w.pipe.setErr(err, false)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2019 smallnest. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package ringbuffer

import (
        "context"
        "errors"
        "io"
        "sync"
        "time"
        "unsafe"
)

var (
        // ErrTooMuchDataToWrite is returned when the data to write is more than the buffer size.
        ErrTooMuchDataToWrite = errors.New("too much data to write")

        // ErrIsFull is returned when the buffer is full and not blocking.
        ErrIsFull = errors.New("ringbuffer is full")

        // ErrIsEmpty is returned when the buffer is empty and not blocking.
        ErrIsEmpty = errors.New("ringbuffer is empty")

        // ErrIsNotEmpty is returned when the buffer is not empty and not blocking.
        ErrIsNotEmpty = errors.New("ringbuffer is not empty")

        // ErrAcquireLock is returned when the lock is not acquired on Try operations.
        ErrAcquireLock = errors.New("unable to acquire lock")

        // ErrWriteOnClosed is returned when write on a closed ringbuffer.
        ErrWriteOnClosed = errors.New("write on closed ringbuffer")

        // ErrReaderClosed is returned when a ReadClosed closed the ringbuffer.
        ErrReaderClosed = errors.New("reader closed")

        // ErrReset is returned when Reset() is called, causing pending operations to abort.
        ErrReset = errors.New("reset called")
)

// RingBuffer is a circular buffer that implements io.ReaderWriter interface.
// It operates like a buffered pipe, where data is written to a RingBuffer
// and can be read back from another goroutine.
// It is safe to concurrently read and write RingBuffer.
type RingBuffer struct {
        buf       []byte
        size      int
        r         int // next position to read
        w         int // next position to write
        isFull    bool
        err       error
        block     bool
        overwrite bool          // when true, overwrite old data when buffer is full
        rTimeout  time.Duration // Applies to writes (waits for the read condition)
        wTimeout  time.Duration // Applies to read (wait for the write condition)
        mu        sync.Mutex
        wg        sync.WaitGroup
        readCond  *sync.Cond // Signaled when data has been read.
        writeCond *sync.Cond // Signaled when data has been written.
}

// New returns a new RingBuffer whose buffer has the given size.
func New(size int) *RingBuffer <span class="cov4" title="175">{
        return &amp;RingBuffer{
                buf:  make([]byte, size),
                size: size,
        }
}</span>

// NewBuffer returns a new RingBuffer whose buffer is provided.
func NewBuffer(b []byte) *RingBuffer <span class="cov0" title="0">{
        return &amp;RingBuffer{
                buf:  b,
                size: len(b),
        }
}</span>

// SetBlocking sets the blocking mode of the ring buffer.
// If block is true, Read and Write will block when there is no data to read or no space to write.
// If block is false, Read and Write will return ErrIsEmpty or ErrIsFull immediately.
// By default, the ring buffer is not blocking.
// This setting should be called before any Read or Write operation or after a Reset.
func (r *RingBuffer) SetBlocking(block bool) *RingBuffer <span class="cov4" title="252">{
        r.block = block
        if block </span><span class="cov4" title="252">{
                r.readCond = sync.NewCond(&amp;r.mu)
                r.writeCond = sync.NewCond(&amp;r.mu)
        }</span>
        <span class="cov4" title="252">return r</span>
}

// SetOverwrite sets the overwrite mode of the ring buffer.
// If overwrite is true, Write operations will overwrite the oldest data when the buffer is full,
// similar to a traditional circular buffer. The read pointer will advance to skip overwritten data.
// If overwrite is false (default), Write will return ErrIsFull or block (if blocking mode is enabled).
func (r *RingBuffer) SetOverwrite(overwrite bool) *RingBuffer <span class="cov2" title="9">{
        r.overwrite = overwrite
        return r
}</span>

// WithCancel sets a context to cancel the ring buffer.
// When the context is canceled, the ring buffer will be closed with the context error.
// A goroutine will be started and run until the provided context is canceled.
func (r *RingBuffer) WithCancel(ctx context.Context) *RingBuffer <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        r.CloseWithError(ctx.Err())</span>
                }
        }()
        <span class="cov0" title="0">return r</span>
}

// WithTimeout will set a blocking read/write timeout.
// If no reads or writes occur within the timeout,
// the ringbuffer will be closed and context.DeadlineExceeded will be returned.
// A timeout of 0 or less will disable timeouts (default).
func (r *RingBuffer) WithTimeout(d time.Duration) *RingBuffer <span class="cov3" title="28">{
        r.mu.Lock()
        r.rTimeout = d
        r.wTimeout = d
        r.mu.Unlock()
        return r
}</span>

// WithReadTimeout will set a blocking read timeout.
// Reads refers to any call that reads data from the buffer.
// If no writes occur within the timeout,
// the ringbuffer will be closed and context.DeadlineExceeded will be returned.
// A timeout of 0 or less will disable timeouts (default).
func (r *RingBuffer) WithReadTimeout(d time.Duration) *RingBuffer <span class="cov2" title="7">{
        r.mu.Lock()
        // Read operations wait for writes to complete,
        // therefore we set the wTimeout.
        r.wTimeout = d
        r.mu.Unlock()
        return r
}</span>

// WithWriteTimeout will set a blocking write timeout.
// Write refers to any call that writes data into the buffer.
// If no reads occur within the timeout,
// the ringbuffer will be closed and context.DeadlineExceeded will be returned.
// A timeout of 0 or less will disable timeouts (default).
func (r *RingBuffer) WithWriteTimeout(d time.Duration) *RingBuffer <span class="cov2" title="7">{
        r.mu.Lock()
        // Write operations wait for reads to complete,
        // therefore we set the rTimeout.
        r.rTimeout = d
        r.mu.Unlock()
        return r
}</span>

func (r *RingBuffer) setErr(err error, locked bool) error <span class="cov7" title="22999">{
        if !locked </span><span class="cov4" title="187">{
                r.mu.Lock()
                defer r.mu.Unlock()
        }</span>
        <span class="cov7" title="22999">if r.err != nil &amp;&amp; r.err != io.EOF </span><span class="cov4" title="146">{
                return r.err
        }</span>

        <span class="cov7" title="22853">switch err </span>{
        // Internal errors are transient
        case nil, ErrIsEmpty, ErrIsFull, ErrAcquireLock, ErrTooMuchDataToWrite, ErrIsNotEmpty:<span class="cov7" title="22606">
                return err</span>
        default:<span class="cov4" title="247">
                r.err = err
                if r.block </span><span class="cov4" title="239">{
                        r.readCond.Broadcast()
                        r.writeCond.Broadcast()
                }</span>
        }
        <span class="cov4" title="247">return err</span>
}

func (r *RingBuffer) readErr(locked bool) error <span class="cov10" title="1341528">{
        if !locked </span><span class="cov2" title="8">{
                r.mu.Lock()
                defer r.mu.Unlock()
        }</span>
        <span class="cov10" title="1341528">if r.err != nil </span><span class="cov4" title="272">{
                if r.err == io.EOF </span><span class="cov4" title="231">{
                        if r.w == r.r &amp;&amp; !r.isFull </span><span class="cov4" title="114">{
                                return io.EOF
                        }</span>
                        <span class="cov4" title="117">return nil</span>
                }
                <span class="cov3" title="41">return r.err</span>
        }
        <span class="cov9" title="1341256">return nil</span>
}

// Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &lt;= n &lt;= len(p)) and any error encountered.
// Even if Read returns n &lt; len(p), it may use all of p as scratch space during the call.
// If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.
// When Read encounters an error or end-of-file condition after successfully reading n &gt; 0 bytes, it returns the number of bytes read.
// It may return the (non-nil) error from the same call or return the error (and n == 0) from a subsequent call.
// Callers should always process the n &gt; 0 bytes returned before considering the error err.
// Doing so correctly handles I/O errors that happen after reading some bytes and also both of the allowed EOF behaviors.
func (r *RingBuffer) Read(p []byte) (n int, err error) <span class="cov7" title="15365">{
        if len(p) == 0 </span><span class="cov2" title="8">{
                return 0, r.readErr(false)
        }</span>

        <span class="cov7" title="15357">r.mu.Lock()
        defer r.mu.Unlock()
        if err := r.readErr(true); err != nil </span><span class="cov2" title="8">{
                return 0, err
        }</span>

        <span class="cov7" title="15349">r.wg.Add(1)
        defer r.wg.Done()
        n, err = r.read(p)
        for err == ErrIsEmpty &amp;&amp; r.block </span><span class="cov6" title="10335">{
                if !r.waitWrite() </span><span class="cov2" title="8">{
                        return 0, context.DeadlineExceeded
                }</span>
                <span class="cov6" title="10327">if err = r.readErr(true); err != nil </span><span class="cov2" title="10">{
                        break</span>
                }
                <span class="cov6" title="10317">n, err = r.read(p)</span>
        }
        <span class="cov7" title="15341">if r.block &amp;&amp; n &gt; 0 </span><span class="cov7" title="15313">{
                r.readCond.Broadcast()
        }</span>
        <span class="cov7" title="15341">return n, err</span>
}

// TryRead read up to len(p) bytes into p like Read, but it is never blocking.
// If it does not succeed to acquire the lock, it returns ErrAcquireLock.
func (r *RingBuffer) TryRead(p []byte) (n int, err error) <span class="cov8" title="65174">{
        ok := r.mu.TryLock()
        if !ok </span><span class="cov7" title="37114">{
                return 0, ErrAcquireLock
        }</span>
        <span class="cov7" title="28060">defer r.mu.Unlock()
        if err := r.readErr(true); err != nil </span><span class="cov1" title="4">{
                return 0, err
        }</span>
        <span class="cov7" title="28056">if len(p) == 0 </span><span class="cov1" title="3">{
                return 0, r.readErr(true)
        }</span>

        <span class="cov7" title="28053">n, err = r.read(p)
        if r.block &amp;&amp; n &gt; 0 </span><span class="cov7" title="15048">{
                r.readCond.Broadcast()
        }</span>
        <span class="cov7" title="28053">return n, err</span>
}

// copyFromBuffer copies data from the ring buffer to dst without modifying the read pointer.
// Returns the number of bytes copied. Does not check for errors.
func (r *RingBuffer) copyFromBuffer(dst []byte) int <span class="cov7" title="30860">{
        if r.w == r.r &amp;&amp; !r.isFull </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov7" title="30860">var n int
        if r.w &gt; r.r </span><span class="cov6" title="4981">{
                n = r.w - r.r
                if n &gt; len(dst) </span><span class="cov6" title="3315">{
                        n = len(dst)
                }</span>
                <span class="cov6" title="4981">copy(dst, r.buf[r.r:r.r+n])
                return n</span>
        }

        <span class="cov7" title="25879">n = r.size - r.r + r.w
        if n &gt; len(dst) </span><span class="cov6" title="5449">{
                n = len(dst)
        }</span>

        <span class="cov7" title="25879">if r.r+n &lt;= r.size </span><span class="cov7" title="12929">{
                copy(dst, r.buf[r.r:r.r+n])
        }</span> else<span class="cov7" title="12950"> {
                c1 := r.size - r.r
                copy(dst, r.buf[r.r:r.size])
                c2 := n - c1
                copy(dst[c1:], r.buf[0:c2])
        }</span>
        <span class="cov7" title="25879">return n</span>
}

func (r *RingBuffer) read(p []byte) (n int, err error) <span class="cov7" title="53719">{
        if r.w == r.r &amp;&amp; !r.isFull </span><span class="cov7" title="22863">{
                return 0, ErrIsEmpty
        }</span>

        <span class="cov7" title="30856">n = r.copyFromBuffer(p)
        if n == 0 </span><span class="cov0" title="0">{
                return 0, ErrIsEmpty
        }</span>

        <span class="cov7" title="30856">r.r = (r.r + n) % r.size
        r.isFull = false

        return n, r.readErr(true)</span>
}

// Returns true if a read may have happened.
// Returns false if waited longer than rTimeout.
// Must be called when locked and returns locked.
func (r *RingBuffer) waitRead() (ok bool) <span class="cov8" title="112312">{
        if r.rTimeout &lt;= 0 </span><span class="cov8" title="112280">{
                r.readCond.Wait()
                return true
        }</span>
        <span class="cov3" title="32">start := time.Now()
        defer time.AfterFunc(r.rTimeout, r.readCond.Broadcast).Stop()

        r.readCond.Wait()
        if time.Since(start) &gt;= r.rTimeout </span><span class="cov3" title="32">{
                r.setErr(context.DeadlineExceeded, true)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// ReadByte reads and returns the next byte from the input or ErrIsEmpty.
func (r *RingBuffer) ReadByte() (b byte, err error) <span class="cov7" title="15186">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if err = r.readErr(true); err != nil </span><span class="cov1" title="3">{
                return 0, err
        }</span>
        <span class="cov7" title="15183">for r.w == r.r &amp;&amp; !r.isFull </span><span class="cov6" title="10870">{
                if r.block </span><span class="cov6" title="10869">{
                        if !r.waitWrite() </span><span class="cov2" title="8">{
                                return 0, context.DeadlineExceeded
                        }</span>
                        <span class="cov6" title="10861">err = r.readErr(true)
                        if err != nil </span><span class="cov1" title="3">{
                                return 0, err
                        }</span>
                        <span class="cov6" title="10858">continue</span>
                }
                <span class="cov1" title="1">return 0, ErrIsEmpty</span>
        }
        <span class="cov7" title="15171">b = r.buf[r.r]
        r.r++
        if r.r == r.size </span><span class="cov2" title="5">{
                r.r = 0
        }</span>

        <span class="cov7" title="15171">r.isFull = false
        return b, r.readErr(true)</span>
}

// checkWriteErr checks if the buffer has an error that should prevent writes.
// Returns the appropriate error to return (nil if write can proceed).
// Must be called with mutex held.
func (r *RingBuffer) checkWriteErr() error <span class="cov7" title="20194">{
        if r.err == nil </span><span class="cov7" title="20175">{
                return nil
        }</span>
        <span class="cov2" title="19">if r.err == io.EOF </span><span class="cov2" title="5">{
                return ErrWriteOnClosed
        }</span>
        <span class="cov2" title="14">return r.err</span>
}

// Write writes len(p) bytes from p to the underlying buf.
// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))
// and any error encountered that caused the write to stop early.
// If blocking n &lt; len(p) will be returned only if an error occurred.
// Write returns a non-nil error if it returns n &lt; len(p).
// Write will not modify the slice data, even temporarily.
func (r *RingBuffer) Write(p []byte) (n int, err error) <span class="cov6" title="6151">{
        if len(p) == 0 </span><span class="cov2" title="8">{
                return 0, r.setErr(nil, false)
        }</span>
        <span class="cov6" title="6143">r.mu.Lock()
        defer r.mu.Unlock()
        if err := r.checkWriteErr(); err != nil </span><span class="cov2" title="12">{
                return 0, err
        }</span>
        <span class="cov6" title="6131">wrote := 0
        for len(p) &gt; 0 </span><span class="cov7" title="14512">{
                n, err = r.write(p)
                wrote += n
                if !r.block || err == nil </span><span class="cov6" title="6109">{
                        break</span>
                }
                <span class="cov6" title="8403">err = r.setErr(err, true)
                if r.block &amp;&amp; (err == ErrIsFull || err == ErrTooMuchDataToWrite) </span><span class="cov6" title="8381">{
                        r.writeCond.Broadcast()
                        r.waitRead()
                        p = p[n:]
                        err = nil
                        continue</span>
                }
                <span class="cov2" title="22">break</span>
        }
        <span class="cov6" title="6131">if r.block &amp;&amp; wrote &gt; 0 </span><span class="cov6" title="6075">{
                r.writeCond.Broadcast()
        }</span>

        <span class="cov6" title="6131">return wrote, r.setErr(err, true)</span>
}

// waitWrite will wait for a write event.
// Returns true if a write may have happened.
// Returns false if waited longer than wTimeout.
// Must be called when locked and returns locked.
func (r *RingBuffer) waitWrite() (ok bool) <span class="cov8" title="112740">{
        if r.wTimeout &lt;= 0 </span><span class="cov8" title="112716">{
                r.writeCond.Wait()
                return true
        }</span>

        <span class="cov3" title="24">start := time.Now()
        defer time.AfterFunc(r.wTimeout, r.writeCond.Broadcast).Stop()

        r.writeCond.Wait()
        if time.Since(start) &gt;= r.wTimeout </span><span class="cov3" title="24">{
                r.setErr(context.DeadlineExceeded, true)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// ReadFrom will fulfill the write side of the ringbuffer.
// This will do writes directly into the buffer,
// therefore avoiding a mem-copy when using the Write.
//
// ReadFrom will not automatically close the buffer even after returning.
// For that call CloseWriter().
//
// ReadFrom reads data from r until EOF or error.
// The return value n is the number of bytes read.
// Any error except EOF encountered during the read is also returned,
// and the error will cause the Read side to fail as well.
// ReadFrom only available in blocking mode.
func (r *RingBuffer) ReadFrom(rd io.Reader) (n int64, err error) <span class="cov4" title="125">{
        if !r.block </span><span class="cov0" title="0">{
                return 0, errors.New("RingBuffer: ReadFrom only available in blocking mode")
        }</span>
        <span class="cov4" title="125">zeroReads := 0
        r.mu.Lock()
        defer r.mu.Unlock()
        for </span><span class="cov9" title="1031200">{
                if err = r.readErr(true); err != nil </span><span class="cov2" title="6">{
                        return n, err
                }</span>
                <span class="cov9" title="1031194">if r.isFull </span><span class="cov8" title="103917">{
                        // Wait for a read
                        if !r.waitRead() </span><span class="cov2" title="8">{
                                return 0, context.DeadlineExceeded
                        }</span>
                        <span class="cov8" title="103909">continue</span>
                }

                <span class="cov9" title="927277">var toRead []byte
                if r.w &gt;= r.r </span><span class="cov9" title="910893">{
                        // After reader, read until end of buffer
                        toRead = r.buf[r.w:]
                }</span> else<span class="cov7" title="16384"> {
                        // Before reader, read until reader.
                        toRead = r.buf[r.w:r.r]
                }</span>
                // Unlock while reading
                <span class="cov9" title="927277">r.mu.Unlock()
                nr, rerr := rd.Read(toRead)
                r.mu.Lock()
                if rerr != nil &amp;&amp; rerr != io.EOF </span><span class="cov2" title="10">{
                        err = r.setErr(rerr, true)
                        break</span>
                }
                <span class="cov9" title="927267">if nr == 0 &amp;&amp; rerr == nil </span><span class="cov8" title="92916">{
                        zeroReads++
                        if zeroReads &gt;= 100 </span><span class="cov0" title="0">{
                                err = r.setErr(io.ErrNoProgress, true)
                        }</span>
                        <span class="cov8" title="92916">continue</span>
                }
                <span class="cov9" title="834351">zeroReads = 0
                r.w += nr
                if r.w == r.size </span><span class="cov8" title="104011">{
                        r.w = 0
                }</span>
                <span class="cov9" title="834351">r.isFull = r.r == r.w &amp;&amp; nr &gt; 0
                n += int64(nr)
                r.writeCond.Broadcast()
                if rerr == io.EOF </span><span class="cov3" title="101">{
                        // We do not close.
                        break</span>
                }
        }
        <span class="cov4" title="111">return n, err</span>
}

// WriteTo writes data to w until there's no more data to write or
// when an error occurs. The return value n is the number of bytes
// written. Any error encountered during the write is also returned.
//
// If a non-nil error is returned the write side will also see the error.
func (r *RingBuffer) WriteTo(w io.Writer) (n int64, err error) <span class="cov4" title="129">{
        if !r.block </span><span class="cov0" title="0">{
                return 0, errors.New("RingBuffer: WriteTo only available in blocking mode")
        }</span>
        <span class="cov4" title="129">r.mu.Lock()
        defer r.mu.Unlock()

        // Don't write more than half, to unblock reads earlier.
        maxWrite := len(r.buf) / 2
        // But write at least 8K if possible
        if maxWrite &lt; 8&lt;&lt;10 </span><span class="cov4" title="129">{
                maxWrite = len(r.buf)
        }</span>
        <span class="cov4" title="129">for </span><span class="cov8" title="184481">{
                if err = r.readErr(true); err != nil </span><span class="cov4" title="111">{
                        break</span>
                }
                <span class="cov8" title="184370">if r.r == r.w &amp;&amp; !r.isFull </span><span class="cov8" title="91536">{
                        // Wait for a write to make space
                        if !r.waitWrite() </span><span class="cov2" title="8">{
                                return 0, context.DeadlineExceeded
                        }</span>
                        <span class="cov8" title="91528">continue</span>
                }

                <span class="cov8" title="92834">var toWrite []byte
                if r.r &gt;= r.w </span><span class="cov8" title="91518">{
                        // After writer, we can write until end of buffer
                        toWrite = r.buf[r.r:]
                }</span> else<span class="cov5" title="1316"> {
                        // Before reader, we can read until writer.
                        toWrite = r.buf[r.r:r.w]
                }</span>
                <span class="cov8" title="92834">if len(toWrite) &gt; maxWrite </span><span class="cov0" title="0">{
                        toWrite = toWrite[:maxWrite]
                }</span>
                // Unlock while reading
                <span class="cov8" title="92834">r.mu.Unlock()
                nr, werr := w.Write(toWrite)
                r.mu.Lock()
                if werr != nil </span><span class="cov2" title="10">{
                        n += int64(nr)
                        err = r.setErr(werr, true)
                        break</span>
                }
                <span class="cov8" title="92824">if nr != len(toWrite) </span><span class="cov0" title="0">{
                        err = r.setErr(io.ErrShortWrite, true)
                        break</span>
                }
                <span class="cov8" title="92824">r.r += nr
                if r.r == r.size </span><span class="cov8" title="91508">{
                        r.r = 0
                }</span>
                <span class="cov8" title="92824">r.isFull = false
                n += int64(nr)
                r.readCond.Broadcast()</span>
        }
        <span class="cov4" title="121">if err == io.EOF </span><span class="cov3" title="100">{
                err = nil
        }</span>
        <span class="cov4" title="121">return n, err</span>
}

// Copy will pipe all data from the reader to the writer through the ringbuffer.
// The ringbuffer will switch to blocking mode.
// Reads and writes will be done async.
// No internal mem-copies are used for the transfer.
//
// Calling CloseWithError will cancel the transfer and make the function return when
// any ongoing reads or writes have finished.
//
// Calling Read or Write functions concurrently with running this will lead to unpredictable results.
func (r *RingBuffer) Copy(dst io.Writer, src io.Reader) (written int64, err error) <span class="cov3" title="110">{
        r.SetBlocking(true)
        var wg sync.WaitGroup
        wg.Add(1)
        go func() </span><span class="cov3" title="110">{
                defer wg.Done()
                r.ReadFrom(src)
                r.CloseWriter()
        }</span>()
        <span class="cov3" title="110">defer wg.Wait()
        return r.WriteTo(dst)</span>
}

// TryWrite writes len(p) bytes from p to the underlying buf like Write, but it is not blocking.
// If it does not succeed to acquire the lock, it returns ErrAcquireLock.
func (r *RingBuffer) TryWrite(p []byte) (n int, err error) <span class="cov7" title="53004">{
        if len(p) == 0 </span><span class="cov1" title="2">{
                return 0, r.setErr(nil, false)
        }</span>
        <span class="cov7" title="53002">ok := r.mu.TryLock()
        if !ok </span><span class="cov7" title="44889">{
                return 0, ErrAcquireLock
        }</span>
        <span class="cov6" title="8113">defer r.mu.Unlock()
        if err := r.checkWriteErr(); err != nil </span><span class="cov1" title="2">{
                return 0, err
        }</span>

        <span class="cov6" title="8111">n, err = r.write(p)
        if r.block &amp;&amp; n &gt; 0 </span><span class="cov6" title="2938">{
                r.writeCond.Broadcast()
        }</span>
        <span class="cov6" title="8111">return n, r.setErr(err, true)</span>
}

func (r *RingBuffer) write(p []byte) (n int, err error) <span class="cov7" title="22623">{
        // In overwrite mode, we always allow writing by discarding old data
        if r.overwrite &amp;&amp; r.isFull &amp;&amp; len(p) &gt; 0 </span><span class="cov2" title="7">{
                // Write will overwrite old data
                // First, advance read pointer to make room
                needed := len(p)
                // Discard 'needed' bytes by advancing read pointer
                r.r = (r.r + needed) % r.size
                r.isFull = false
        }</span>

        <span class="cov7" title="22623">if r.isFull </span><span class="cov6" title="5095">{
                return 0, ErrIsFull
        }</span>

        <span class="cov7" title="17528">var avail int
        if r.w &gt;= r.r </span><span class="cov7" title="13733">{
                avail = r.size - r.w + r.r
        }</span> else<span class="cov6" title="3795"> {
                avail = r.r - r.w
        }</span>

        <span class="cov7" title="17528">if len(p) &gt; avail </span><span class="cov6" title="8860">{
                err = ErrTooMuchDataToWrite
                p = p[:avail]
        }</span>
        <span class="cov7" title="17528">n = len(p)

        if r.w &gt;= r.r </span><span class="cov7" title="13733">{
                c1 := r.size - r.w
                if c1 &gt;= n </span><span class="cov6" title="4579">{
                        copy(r.buf[r.w:], p)
                        r.w += n
                }</span> else<span class="cov6" title="9154"> {
                        copy(r.buf[r.w:], p[:c1])
                        c2 := n - c1
                        copy(r.buf[0:], p[c1:])
                        r.w = c2
                }</span>
        } else<span class="cov6" title="3795"> {
                copy(r.buf[r.w:], p)
                r.w += n
        }</span>

        <span class="cov7" title="17528">if r.w == r.size </span><span class="cov3" title="79">{
                r.w = 0
        }</span>
        <span class="cov7" title="17528">if r.w == r.r </span><span class="cov6" title="8923">{
                r.isFull = true
        }</span>

        <span class="cov7" title="17528">return n, err</span>
}

// WriteByte writes one byte into buffer, and returns ErrIsFull if the buffer is full.
func (r *RingBuffer) WriteByte(c byte) error <span class="cov6" title="3019">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if err := r.checkWriteErr(); err != nil </span><span class="cov1" title="3">{
                return err
        }</span>
        <span class="cov6" title="3016">err := r.writeByte(c)
        for err == ErrIsFull &amp;&amp; r.block </span><span class="cov2" title="10">{
                if !r.waitRead() </span><span class="cov2" title="8">{
                        return context.DeadlineExceeded
                }</span>
                <span class="cov1" title="2">err = r.setErr(r.writeByte(c), true)</span>
        }
        <span class="cov6" title="3008">if r.block &amp;&amp; err == nil </span><span class="cov6" title="3000">{
                r.writeCond.Broadcast()
        }</span>
        <span class="cov6" title="3008">return err</span>
}

// TryWriteByte writes one byte into buffer without blocking.
// If it does not succeed to acquire the lock, it returns ErrAcquireLock.
func (r *RingBuffer) TryWriteByte(c byte) error <span class="cov6" title="3002">{
        ok := r.mu.TryLock()
        if !ok </span><span class="cov3" title="83">{
                return ErrAcquireLock
        }</span>
        <span class="cov6" title="2919">defer r.mu.Unlock()
        if err := r.checkWriteErr(); err != nil </span><span class="cov1" title="2">{
                return err
        }</span>

        <span class="cov6" title="2917">err := r.writeByte(c)
        if err == nil &amp;&amp; r.block </span><span class="cov5" title="2197">{
                r.writeCond.Broadcast()
        }</span>
        <span class="cov6" title="2917">return err</span>
}

func (r *RingBuffer) writeByte(c byte) error <span class="cov6" title="5935">{
        if r.err != nil </span><span class="cov1" title="2">{
                return r.err
        }</span>
        <span class="cov6" title="5933">if r.w == r.r &amp;&amp; r.isFull </span><span class="cov5" title="732">{
                // In overwrite mode, discard the oldest byte and write the new one
                if r.overwrite </span><span class="cov1" title="1">{
                        r.r++
                        if r.r == r.size </span><span class="cov0" title="0">{
                                r.r = 0
                        }</span>
                } else<span class="cov5" title="731"> {
                        return ErrIsFull
                }</span>
        }
        <span class="cov6" title="5202">r.buf[r.w] = c
        r.w++

        if r.w == r.size </span><span class="cov1" title="4">{
                r.w = 0
        }</span>
        <span class="cov6" title="5202">if r.w == r.r </span><span class="cov2" title="10">{
                r.isFull = true
        }</span>

        <span class="cov6" title="5202">return nil</span>
}

// Length returns the number of bytes that can be read without blocking.
func (r *RingBuffer) Length() int <span class="cov3" title="27">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.w == r.r </span><span class="cov2" title="17">{
                if r.isFull </span><span class="cov2" title="8">{
                        return r.size
                }</span>
                <span class="cov2" title="9">return 0</span>
        }

        <span class="cov2" title="10">if r.w &gt; r.r </span><span class="cov2" title="9">{
                return r.w - r.r
        }</span>

        <span class="cov1" title="1">return r.size - r.r + r.w</span>
}

// Capacity returns the size of the underlying buffer.
func (r *RingBuffer) Capacity() int <span class="cov0" title="0">{
        return r.size
}</span>

// Free returns the number of bytes that can be written without blocking.
func (r *RingBuffer) Free() int <span class="cov3" title="25">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.w == r.r </span><span class="cov2" title="18">{
                if r.isFull </span><span class="cov2" title="10">{
                        return 0
                }</span>
                <span class="cov2" title="8">return r.size</span>
        }

        <span class="cov2" title="7">if r.w &lt; r.r </span><span class="cov1" title="1">{
                return r.r - r.w
        }</span>

        <span class="cov2" title="6">return r.size - r.w + r.r</span>
}

// WriteString writes the contents of the string s to buffer, which accepts a slice of bytes.
func (r *RingBuffer) WriteString(s string) (n int, err error) <span class="cov6" title="3009">{
        x := (*[2]uintptr)(unsafe.Pointer(&amp;s))
        h := [3]uintptr{x[0], x[1], x[1]}
        buf := *(*[]byte)(unsafe.Pointer(&amp;h))
        return r.Write(buf)
}</span>

// Bytes returns all available read bytes.
// It does not move the read pointer and only copy the available data.
// If the dst is big enough, it will be used as destination,
// otherwise a new buffer will be allocated.
func (r *RingBuffer) Bytes(dst []byte) []byte <span class="cov2" title="19">{
        r.mu.Lock()
        defer r.mu.Unlock()
        getDst := func(n int) []byte </span><span class="cov2" title="19">{
                if cap(dst) &lt; n </span><span class="cov2" title="17">{
                        return make([]byte, n)
                }</span>
                <span class="cov1" title="2">return dst[:n]</span>
        }

        <span class="cov2" title="19">if r.w == r.r </span><span class="cov2" title="8">{
                if r.isFull </span><span class="cov2" title="8">{
                        buf := getDst(r.size)
                        copy(buf, r.buf[r.r:])
                        copy(buf[r.size-r.r:], r.buf[:r.w])
                        return buf
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov2" title="11">if r.w &gt; r.r </span><span class="cov2" title="7">{
                buf := getDst(r.w - r.r)
                copy(buf, r.buf[r.r:r.w])
                return buf
        }</span>

        <span class="cov1" title="4">n := r.size - r.r + r.w
        buf := getDst(n)

        if r.r+n &lt; r.size </span><span class="cov0" title="0">{
                copy(buf, r.buf[r.r:r.r+n])
        }</span> else<span class="cov1" title="4"> {
                c1 := r.size - r.r
                copy(buf, r.buf[r.r:r.size])
                c2 := n - c1
                copy(buf[c1:], r.buf[0:c2])
        }</span>

        <span class="cov1" title="4">return buf</span>
}

// IsFull returns true when the ringbuffer is full.
func (r *RingBuffer) IsFull() bool <span class="cov2" title="15">{
        r.mu.Lock()
        defer r.mu.Unlock()

        return r.isFull
}</span>

// IsEmpty returns true when the ringbuffer is empty.
func (r *RingBuffer) IsEmpty() bool <span class="cov2" title="15">{
        r.mu.Lock()
        defer r.mu.Unlock()

        return !r.isFull &amp;&amp; r.w == r.r
}</span>

// CloseWithError closes the writer; reads will return
// no bytes and the error err, or EOF if err is nil.
//
// CloseWithError never overwrites the previous error if it exists
// and always returns nil.
func (r *RingBuffer) CloseWithError(err error) <span class="cov3" title="24">{
        if err == nil </span><span class="cov1" title="3">{
                err = io.EOF
        }</span>
        <span class="cov3" title="24">r.setErr(err, false)</span>
}

// CloseWriter closes the writer.
// Reads will return any remaining bytes and io.EOF.
func (r *RingBuffer) CloseWriter() <span class="cov4" title="114">{
        r.setErr(io.EOF, false)
}</span>

// Flush waits for the buffer to be empty and fully read.
// If not blocking ErrIsNotEmpty will be returned if the buffer still contains data.
func (r *RingBuffer) Flush() error <span class="cov2" title="6">{
        r.mu.Lock()
        defer r.mu.Unlock()
        for r.w != r.r || r.isFull </span><span class="cov2" title="5">{
                err := r.readErr(true)
                if err != nil </span><span class="cov1" title="1">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                err = nil
                        }</span>
                        <span class="cov1" title="1">return err</span>
                }
                <span class="cov1" title="4">if !r.block </span><span class="cov0" title="0">{
                        return ErrIsNotEmpty
                }</span>
                <span class="cov1" title="4">if !r.waitRead() </span><span class="cov0" title="0">{
                        return context.DeadlineExceeded
                }</span>
        }

        <span class="cov2" title="5">err := r.readErr(true)
        if err == io.EOF </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov2" title="5">return err</span>
}

// Reset the read pointer and writer pointer to zero.
func (r *RingBuffer) Reset() <span class="cov3" title="89">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Set error so any readers/writers will return immediately.
        r.setErr(ErrReset, true)
        if r.block </span><span class="cov3" title="82">{
                r.readCond.Broadcast()
                r.writeCond.Broadcast()
        }</span>

        // Unlock the mutex so readers/writers can finish.
        <span class="cov3" title="89">r.mu.Unlock()
        r.wg.Wait()
        r.mu.Lock()
        r.r = 0
        r.w = 0
        r.err = nil
        r.isFull = false</span>
}

// WriteCloser returns a WriteCloser that writes to the ring buffer.
// When the returned WriteCloser is closed, it will wait for all data to be read before returning.
func (r *RingBuffer) WriteCloser() io.WriteCloser <span class="cov0" title="0">{
        return &amp;writeCloser{RingBuffer: r}
}</span>

type writeCloser struct {
        *RingBuffer
}

// Close provides a close method for the WriteCloser.
func (wc *writeCloser) Close() error <span class="cov0" title="0">{
        wc.CloseWriter()
        return wc.Flush()
}</span>

// ReadCloser returns a io.ReadCloser that reads to the ring buffer.
// When the returned ReadCloser is closed, ErrReaderClosed will be returned on any writes done afterwards.
func (r *RingBuffer) ReadCloser() io.ReadCloser <span class="cov0" title="0">{
        return &amp;readCloser{RingBuffer: r}
}</span>

type readCloser struct {
        *RingBuffer
}

// Close provides a close method for the ReadCloser.
func (rc *readCloser) Close() error <span class="cov0" title="0">{
        rc.CloseWithError(ErrReaderClosed)
        err := rc.readErr(false)
        if err == ErrReaderClosed </span><span class="cov0" title="0">{
                err = nil
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Peek reads up to len(p) bytes into p without moving the read pointer.
func (r *RingBuffer) Peek(p []byte) (n int, err error) <span class="cov1" title="4">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return 0, r.readErr(false)
        }</span>

        <span class="cov1" title="4">r.mu.Lock()
        defer r.mu.Unlock()
        if err := r.readErr(true); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="4">return r.peek(p)</span>
}

func (r *RingBuffer) peek(p []byte) (n int, err error) <span class="cov1" title="4">{
        n = r.copyFromBuffer(p)
        if n == 0 </span><span class="cov0" title="0">{
                return 0, ErrIsEmpty
        }</span>
        <span class="cov1" title="4">return n, r.readErr(true)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
